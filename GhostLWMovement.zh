//This header contains all the movement functions


//Calls the movement update functions
void UpdateGhostLWMovement(lweapon weapon){
	if(IsGhostedLWeapon(weapon)){
		int intflag = GetGhostLWData(weapon, __GhostLW_Flags_Int);
		//Override the default ZC gravity
		float movement = GetGhostLWData(weapon, GhostLW_Move);
		if(weapon->Jump != 0){
			weapon->Jump = 0;
		}
		if((intflag&__LWFI_AIRBORNE) != 0){
			if((GetGhostLWData(weapon, GhostLW_Z) <= 0) && movement != 5){
				weapon->Step = 0;
			}
		}
		//Split the conditionals into brackets of 5 to reduce checks
		if(movement <= LWM_BOUNCE){
			if(movement == LWM_VEER){
				__GhostLWUpdateVeer(weapon);
			}
			else if(movement == LWM_DRIFT){
				__GhostLWUpdateDrift(weapon);
			}
			else if(movement == LWM_REAIM){
				__GhostLWUpdateReaim(weapon);
			}
			else if(movement == LWM_SINE){
				__GhostLWUpdateSine(weapon);
			}
			else if(movement == LWM_BOUNCE){
				__GhostLWUpdateBounce(weapon);
			}
		}
		else if(movement <= LWM_CORBIT){
			if(movement == LWM_HOMING){
				__GhostLWUpdateHoming(weapon);
			}
			else if(movement == LWM_CHASING){
			}
			else if(movement == LWM_WALLBOUNCE){
			}
			else if(movement == LWM_ORBIT || movement == LWM_CORBIT){
			}
		}
		float endx = GetGhostLWData(weapon, GhostLW_X);
		float endy = GetGhostLWData(weapon, GhostLW_Y);
		float endz = GetGhostLWData(weapon, GhostLW_Z);
		float endjump = GetGhostLWData(weapon, GhostLW_Jump);
		//One of set movement types. Use the ghosted weapon X/Y vars.
		if(movement >= 0 && movement != 4){
			//Handle normal movement.
			endx += VectorX(weapon->Step/100, RadtoDeg(weapon->Angle));
			if(IsSideview() && (intflag&__LWFI_AIRBORNE) != 0 &&){
				endy += VectorY(weapon->Step/100, RadtoDeg(weapon->Angle));
			}
			else{
				endy += VectorY(weapon->Step/100, RadtoDeg(weapon->Angle))+endjump;
			}
		}
		
		//Handle Z movement and gravity
		//Need to make it modular for both standard screens and Sideview screens. Maybe add the Z to the Y at this point in those cases?
		if(endz > 0 || endjump != 0){
			endz += endjump;
			if((intflag&__LWFI_AIRBORNE) == 0){
				if(endz >= 8 || (!OnSidePlatform(endx, endy, weapon->HitXOffset, weapon->HitYOffset, weapon->HitHeight) && IsSideview()) || endjump >= 2){
					intflag |= __LWFI_AIRBORNE;
				}
			}
			endjump -= GHOSTLW_GRAVITY;
		}
		else{
			if(endjump != 0 && movement != 5){
				endjump = 0;
			}
		}
		//Clamp the vars related to jumping to avoid instances of negative Z or falling beyond terminal velocity.
		endz = Clamp(endz, 0, 256);
		if((GetGhostLWData(weapon, GhostLW_Flags)&LWF_NOFALL) == 0){
			endjump = Clamp(endjump, GHOSTLW_TERMINALVELOCITY*-1, 256);
		}
		else{
			endjump = Clamp(endjump, 0, 256);
		}
		weapon->X = endx;
		weapon->Y = endy;
		if(GHOSTLW_SETTING_FAKE_Z <= 0 && !IsSideview()){
			weapon->Z = endz;
		}
		else{
			weapon->Y -= endz;
			weapon->Z = 0;
		}
		//Trace(endy);
		//Trace(weapon->Y);
		//Trace(endz);
		//Trace(weapon->Z);
		//TraceNL();
		SetGhostLWData(weapon, GhostLW_X, endx);
		SetGhostLWData(weapon, GhostLW_Y, endy);
		SetGhostLWData(weapon, GhostLW_Z, endz);
		SetGhostLWData(weapon, GhostLW_Jump, endjump);
		SetGhostLWData(weapon, __GhostLW_Flags_Int, intflag);
	}
}

//LWeapon accelerates off in a given direction
//arg1 - Direction of veer. Use positive numbers if you want to use the eight cardinal directions. Use negative numbers if you want to use an angle.
//arg2 - Speed, in 10000ths of a pixel, to accelerate per frame.
void __GhostLWUpdateVeer(lweapon weapon){
	float startx = GetGhostLWData(weapon, GhostLW_X);
	float starty = GetGhostLWData(weapon, GhostLW_Y);
	float dir = GetGhostLWData(weapon, GhostLW_Move_Arg1);
	float speed = GetGhostLWData(weapon, GhostLW_Move_Arg2);
	float angle = 0;
	float mov = GetGhostLWData(weapon, __GhostLW_Move_Work1);
	
	angle = GhostLWAngleOrDir(dir);
	
	//Update the acceleration speed
	//Sanity checks to stop the script from overflowing or underflowing the work variables. You normally shouldn't end up doing this, but just in case... 
	mov = VBound(mov+(speed/10000), MAX_CONSTANT, MAX_CONSTANT*-1);
	
	//Move the weapon and update the variables
	startx += VectorX(mov, angle);
	starty += VectorY(mov, angle);
	SetGhostLWData(weapon, GhostLW_X, startx);
	SetGhostLWData(weapon, GhostLW_Y, starty);
	SetGhostLWData(weapon, __GhostLW_Move_Work1, mov);
}

//LWeapon drifts in a given direction
//arg1 - Direction of drifting. Use positive numbers if you want to use the eight cardinal directions. Use negative numbers if you want to use an angle.
//arg2 - Speed, in 100ths of a pixel, to drift per frame.
void __GhostLWUpdateDrift(lweapon weapon){
	int startx = GetGhostLWData(weapon, GhostLW_X);
	int starty = GetGhostLWData(weapon, GhostLW_Y);
	int dir = GetGhostLWData(weapon, GhostLW_Move_Arg1);
	int speed = GetGhostLWData(weapon, GhostLW_Move_Arg2)/100;
	int angle = 0;
	
	angle = GhostLWAngleOrDir(dir);
	
	//Move the weapon and update the variables
	startx += VectorX(speed, angle);
	starty += VectorY(speed, angle);
	SetGhostLWData(weapon, GhostLW_X, startx);
	SetGhostLWData(weapon, GhostLW_Y, starty);
}


//LWeapon reaims
//arg1 - Direction of reaim. Use positive numbers if you want to use the eight cardinal directions, use negative numbers if you want to use an angle.
//arg2 - Time before reaiming.
void __GhostLWUpdateReaim(lweapon weapon){
	int angle = GhostLWAngleOrDir(GetGhostLWData(weapon, GhostLW_Move_Arg1));
	int timer = GetGhostLWData(weapon, GhostLW_Move_Arg2);
	int time = GetGhostLWData(weapon, __GhostLW_Move_Work1);
	if(time < timer && time >= 0){
		time ++;
	}
	else if(time >= timer){
		weapon->Angle = DegtoRad(angle);
		time = -1;
	}
	SetGhostLWData(weapon, __GhostLW_Move_Work1, time);
}

//Weapon moves in a sine wave. Taken directly from Ghost.zh and adapted to this header. I don't understand sine waves >_>
//arg1 = amplitude
//arg2 = Angular frequency in degrees per frame
void __GhostLWUpdateSine(lweapon weapon){
	int curangle;
    float offset;
	float startx = GetGhostLWData(weapon, GhostLW_X);
	float starty = GetGhostLWData(weapon, GhostLW_Y);
	int amp = GetGhostLWData(weapon, GhostLW_Move_Arg1);
	int angle = GetGhostLWData(weapon, GhostLW_Move_Arg2);
	float work = GetGhostLWData(weapon, __GhostLW_Move_Work1);
	float fakex = startx;
	float fakey = starty;
    work += angle;
    
    // Adjust the weapon's position at an angle
    // perpendicular to that of its forward movement.
    offset = amp*Sin(work);
	
	//Keep the sine wave moving
    fakex += (weapon->Step/100)*RadianCos(weapon->Angle);
    fakey += (weapon->Step/100)*RadianSin(weapon->Angle);
	
	//Okay, here's the actual position setting
    startx=fakex+offset*RadianCos(weapon->Angle+1.5708);
    starty=fakey+offset*RadianSin(weapon->Angle+1.5708);
	
	SetGhostLWData(weapon, GhostLW_X, startx);
	SetGhostLWData(weapon, GhostLW_Y, starty);
	SetGhostLWData(weapon, __GhostLW_Move_Work1, work);
}

//Ghosted weapon bounces back up after landing.
//arg1 = % of upwards velocity and step speed kept from previous bounce
//arg2 = Maximum number of bounces.
void __GhostLWUpdateBounce(lweapon weapon){
	float startz = GetGhostLWData(weapon, GhostLW_Z);
	float startjump = GetGhostLWData(weapon, GhostLW_Jump);
	float jumpfactor = GetGhostLWData(weapon, GhostLW_Move_Arg1)/100;
	float maxjumps = GetGhostLWData(weapon, GhostLW_Move_Arg2);
	float nextjump = GetGhostLWData(weapon, __GhostLW_Move_Work1);
	float curjump = GetGhostLWData(weapon, __GhostLW_Move_Work2);
	if(nextjump == 0 && startz > 0 && curjump <= maxjumps){
		nextjump = startjump;
	}
	//Weapon rebounds up.
	if(startz <= 0 && curjump <= maxjumps){
		startz = 1;
		startjump = nextjump*jumpfactor;
		nextjump = nextjump*jumpfactor;
		weapon->Step = weapon->Step*jumpfactor;
		curjump ++;
	}
	if(curjump > maxjumps){
		weapon->Step = 0;
		startjump = -0.01;
	}
	
	
	SetGhostLWData(weapon, GhostLW_Z, startz);
	SetGhostLWData(weapon, GhostLW_Jump, startjump);
	SetGhostLWData(weapon, __GhostLW_Move_Work1, nextjump);
	SetGhostLWData(weapon, __GhostLW_Move_Work2, curjump);
}

//LWeapon homes in on an NPC
//arg1 - NPC targeted
//arg2 - Maximum turn per frame
void __GhostLWUpdateHoming(lweapon weapon){
	int homtarget = GetGhostLWData(weapon, GhostLW_Move_Arg1);
	npc target;
	float maxturn = GetGhostLWData(weapon, GhostLW_Move_Arg2)/100;
	int previouscount = GetGhostLWData(weapon, __GhostLW_Move_Work1);
	//Initial checks; Is the NPC still alive and make sure weapon stays locked onto the NPC.
	if(Screen->NumNPCs() != previouscount){
		homtarget += (previouscount-Screen->NumNPCs());
		previouscount = Screen->NumNPCs();
	}
	if(homtarget > 0 || homtarget <= Screen->NumNPCs()){
		target = Screen->LoadNPC(homtarget);
	}
	if(target->isValid() && target->HP > 0){
		//Now, home in.
		weapon->Angle = TurnTowards(weapon->X, weapon->Y, target->X, target->Y, PI, maxturn);
	}
}