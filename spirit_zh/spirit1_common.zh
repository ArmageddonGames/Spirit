namespace Spirit
{
	untyped Global[GLOBAL_SZ]; //Global array for handling global switches
	enum GlobalIndex
	{
		GLOBAL_SUSPEND, //The index for wherever the header is suspended or not. While suspended, Spirit_Waitframe does not return; keeping the weapons motionless. Global[GLOBAL_SUSPEND] <= 0, not suspended. Global[GLOBAL_SUSPEND] > 0, suspended.
		GLOBAL_SZ
	};

	DEFINE HITWEAPON_DUR = 1; //How long hitting LWeapons persist.


	//LWeapon flags. OR (|) them together when setting spirit->Misc[LWMISC_FLAGS]
	//None of these except LWF_PIERCING and LWF_ALIVE are functional
	DEFINE LWF_OBEYSOLID     = 0x0001; //Weapon respects combo solidity. The status of this flag is overridden by LWM_WALLBOUNCE. This however, does not stop it from getting blocked by combos which block it.
	DEFINE LWF_PIERCING      = 0x0002; //Weapon does not die or vanish after hitting an enemy
	DEFINE LWF_UNBLOCKABLE   = 0x0004; //Weapon can not be blocked by shields.
	DEFINE LWF_NOFALL        = 0x0008; //Weapon obeys height physics when weapon->Jump is set. This will reduce the weapon's step speed as it travels through the air.
	DEFINE LWF_JUMPPHYSICS   = 0x0010; //Weapon obeys height physics when weapon->Jump is set. This will reduce the weapon's step speed as it travels through the air.
	DEFINE LWF_DUMMY         = 0x0100; //Weapon does not move or hit enemies and can be controlled for other purposes.
	//Flags which are set internally, but the user can read/write freely if they want to
	DEFINE LWF_ALIVE         = 0x1000; //Weapon is alive. This is set internally
	
	DEFINE MAX_WORKSIZE = 3; //The largest size your 'work[]' array ever needs to be. This may get larger, so, use the constant, not the value!

	//Creates a basic spirited LWeapon with all the basic attributes and returns the pointer.
	lweapon Spirit_CreateWeapon(int type, int wscrpt, int weaponD, int parent, int x, int y, int damage, int step, int angle, int sprite, int sfx, int flags)
	{
		lweapon spirit = RunLWeaponScript(type, wscrpt, weaponD);
		if(spirit->isValid())
		{
			spirit->X = x;
			spirit->Y = y;
			spirit->Damage = damage;
			spirit->Step = step;
			spirit->Angular = true;
			spirit->Angle = angle;
			spirit->UseSprite(sprite);
			spirit->Parent = parent;
			spirit->Misc[LWMISC_FLAGS] = (flags | LWF_ALIVE);
			spirit->Misc[LWMISC_FLAGS_INT] = LWFI_ISSPIRIT;
			
			return spirit;
		}
		else //This probably shouldn't happen, but for good measure...
		{
			ERROR("Spirit_CreateWeapon", "Failed to create lweapon");
			return NULL;
		}
	}

	//Creates an LWeapon and assigns it a script and script args.
	//Created by Venrob, edited by Zoria RPG.
	lweapon RunLWeaponScript(int ID, int scriptNum, untyped args)
	{
		// Invalid script
		if(scriptNum < 0 || scriptNum > 511) // Why allow script 0 here?
			return NULL;
		
		lweapon weap = Screen->CreateLWeapon(ID);
		weap->Script = scriptNum;
		for(int q = Min(SizeOfArray(args)-1,7); q >= 0; --q)
		{
			weap->InitD[q] = args[q];
		}
		return weap;
	}
	//Supply a float array of size 1 or higher to use. Otherwise it does nothing.
	//Args:
	//	acc - Step Speed at which the weapon accelerates in. 100 = 1 pixel per frame (you probably don't want it this high unless you know what you are doing)
	//	angle - Angle, in degrees, at which weapon accelerates in. 
	//Work indicies:
	//	0 - Current acceleration level, in 100ths of a pixel per frame.
	void Spirit_Move_Veer(lweapon spirit, untyped work, float acc, int angle)
	{
		DEFINE WORKSIZE = 1;
		CONST_ASSERT(WORKSIZE <= MAX_WORKSIZE, "MAX_WORKSIZE too small!");
		if(SizeOfArray(work) >= WORKSIZE && Spirit_IsSpiritLW(spirit))
		{
			work[0] += acc/100;
			spirit->X += VectorX((work[0]), angle);
			spirit->Y += VectorY((work[0]), angle);
		}
		else
		{
			ERROR("Spirit_Move_Veer", SizeOfArray(work) < WORKSIZE ? "Bad Array Size" : "Not a Spirit Weapon");
		}
	}

	//Weapon drifts in a given direction
	//Args:
	//	step - Step Speed at which the weapon drifts in. 100 = 1 pixel per frame.
	//	angle - Angle, in degrees, at which weapon drifts in. 
	void Spirit_Move_Drift(lweapon spirit, float step, int angle)
	{
		if(Spirit_IsSpiritLW(spirit))
		{
			spirit->X += VectorX(step/100, angle);
			spirit->Y += VectorY(step/100, angle);
		}
		else
		{
			ERROR("Spirit_Move_Drift", "Not a Spirit Weapon");
		}
	}

	//Weapon moves in a sine wave. The functional bits of code are taken straight from Ghost.zh and adapted for this header. I do not understand sine waves >.>
	//Supply a float array of size 3 or higher to use. Otherwise, it does nothing.
	//Args:
	//	amplitude - the overall amplitude the sine wave moves at.
	//	initangle - The initial angle.
	//	angle - The angular frequency, in degrees, per frame. Set to a negative number to produce Cosine movement.
	//Work indicies:
	//	0 - The current angle.
	//	1 - Working variable that is applied to the weapon's X movement.
	//	2 - Ditto, but for the weapon's Y movement.
	void Spirit_Move_Sine(lweapon spirit, untyped work, float amp, float initangle, float angle)
	{
		DEFINE WORKSIZE = 1;
		CONST_ASSERT(WORKSIZE <= MAX_WORKSIZE, "MAX_WORKSIZE too small!");
		if(SizeOfArray(work) >= WORKSIZE && Spirit_IsSpiritLW(spirit))
		{
			work[0] += angle;
			// Adjust the weapon's position at an angle
			// perpendicular to that of its forward movement.
			float offset = amp*Sin(work[0]+initangle);
		
			//Okay, here's the actual position setting
			spirit->X += offset*RadianCos(spirit->Angle+(PI/2));
			spirit->Y += offset*RadianSin(spirit->Angle+(PI/2));
		}
		else
		{
			ERROR("Spirit_Move_Sine", SizeOfArray(work) < WORKSIZE ? "Bad Array Size" : "Not a Spirit Weapon");
		}
	}

	//----------------
	//|||INCOMPLETE|||
	//----------------
	//Weapon bounces in the air, bounding along the ground. It stops bouncing if 
	//Supply a float array of 3 or higher if you don't have the setting. Otherwise, supply a float array of 4
	//Args:
	//	initjump - Initial upward velocity
	//	jumpdecay - How much is removed from the initial upward velocity after each bounce
	//	stepdecay - How much is removed from the weapon's step speed after each bounce.
	//Work Indicies:
	//	0 - The stored upward velocity, adjusted each time the weapon bounces.
	//	1 - The current bounce number. This does nothing in the weapon itself beyond the first bounce - it is an easy way for the user to read the number of bounces the weapon has made.
	//	The following only apply if the fake Z axis setting is turned on. 
	//	2 - Weapon's fake Z value
	void Spirit_Move_Bounce(lweapon spirit, untyped work, float initjump, float jumpdecay, float stepdecay)
	{
		DEFINE WORKSIZE = 3;
		CONST_ASSERT(WORKSIZE <= MAX_WORKSIZE, "MAX_WORKSIZE too small!");
		if(SizeOfArray(work) >= WORKSIZE && Spirit_IsSpiritLW(spirit)) //Z axis setting is not set to fake.
		{
			if(work[1] <= 0)
			{
				work[0] = initjump;
				work[1] = 1;
			}
			else
			{
				unless(IsSideview()) //Handling for top down
				{
					unless(SETTING_FAKE_Z)
					{
						//spirit->Z = Max(spirit->Z+work[0], 0);
						//work[0] = Max(Game->Gravity[GR_TERMINALV]*-1, work[0]-Game->Gravity[GR_STRENGTH]);
						if(spirit->Z <= 0) //Now rebound off the ground
						{
							//spirit->Z = 0;
							spirit->Jump = work[0];
							work[0] = Max(0, work[0]-jumpdecay);
							spirit->Step = Max(0, spirit->Step-jumpdecay);
							++work[1];
						}
					}
					else
					{
						ERROR("Spirit_Move_Bounce","Function does not work with fake Z (yet)");
					}
				}
				else //Handling for sideview
				{
					ERROR("Spirit_Move_Bounce","Function does not work in sideview (yet)");
				}
			}
		}
		else
		{
			ERROR("Spirit_Move_Bounce", SizeOfArray(work) < WORKSIZE ? "Bad Array Size" : "Not a Spirit Weapon");
		}
	}
	//----------------
	//|||INCOMPLETE|||
	//----------------

	//Weapon moves in an orbit
	void Spirit_Move_Orbit(lweapon spirit, untyped work, int orbit, int increment)
	{
		DEFINE WORKSIZE = 1;
		CONST_ASSERT(WORKSIZE <= MAX_WORKSIZE, "MAX_WORKSIZE too small!");
		if(SizeOfArray(work) >= WORKSIZE && Spirit_IsSpiritLW(spirit))
		{
			ERROR("Spirit_Move_Orbit", "Function is not yet implemented");
		}
		else
		{
			ERROR("Spirit_Move_Orbit", SizeOfArray(work) < WORKSIZE ? "Bad Array Size" : "Not a Spirit Weapon");
		}
	}

	//Handles internal stuff for spirited weapons.
	bool Spirit_Waitframe(lweapon spirit)
	{
		DEFINE SUSPENDSIZE = 4;
		untyped suspend[SUSPENDSIZE];
		/*Keeps track of various things to be kept track of when the header is suspended.
		0 - Amount of time header has been suspended for (int)
		1 - Stored step speed (float)
		2 - Stored Collision Detection (bool)
		3 - Stored Gravity Obedience (bool)*/
		
		//Piercing weapons stay alive after hitting enemies
		if(spirit->Misc[LWMISC_FLAGS]&LWF_PIERCING)
			spirit->DeadState = WDS_ALIVE;
		
		//Code for handling weapons with gravity
		if(spirit->Gravity)
		{
			//Code for handling weapons that obey gravity in Sideview.
			if(IsSideview())
			{
				//Cut the weapon's jump if it collides with the ceiling of a combo.
				if(spirit->Jump > 0)
				{
					if(SolidRectCollision(spirit->X+spirit->HitXOffset, spirit->Y+spirit->HitYOffset, spirit->X+spirit->HitXOffset+spirit->HitWidth, spirit->Y+spirit->HitYOffset+spirit->HitHeight, 1110b))
					{
						spirit->Jump = 0;
					}
				}
				if(spirit->Step > 0)
				{
					//Halt the weapon if it collides with the sides of a solid combo.
					if(SolidRectCollision(spirit->X+spirit->HitXOffset, spirit->Y+spirit->HitYOffset, spirit->X+spirit->HitXOffset+spirit->HitWidth, spirit->Y+spirit->HitYOffset+spirit->HitHeight, 0011b))
					{
						spirit->Step = 0;
					}
				}
			}
		}
		
		do //This loops for as long as the header is paused
		{
			if(Global[GLOBAL_SUSPEND])
			{
				if(suspend[0] <= 0) //First frame of pause processing - remember movement, wherever weapon has collission or obeys engine gravity.
				{
					suspend[1] = spirit->Step;
					suspend[2] = spirit->CollDetection;
					suspend[3] = spirit->Gravity;
				}
				else
				{
					if(spirit->Step != 0)
						ERROR("Spirit Suspend", "Attempted to set weapon step to a non-zero value while suspended");
					if(spirit->CollDetection)
						ERROR("Spirit Suspend", "Attempted to set weapon collision detection ON while suspended");
					if(spirit->Gravity)
						ERROR("Spirit Suspend", "Attempted to set weapon gravity ON while suspended");
				}
				spirit->Step = 0;
				spirit->CollDetection = false;
				spirit->Gravity = false;
				++suspend[0];
			}
			Waitframe();
		}
		while(Global[GLOBAL_SUSPEND]);
		
		//Restore weapon's previous parameters following a pause
		if(suspend[1] > 0)
			spirit->Step = suspend[1];
		if(suspend[2])
			spirit->CollDetection = true;
		if(suspend[3])
			spirit->Gravity = true;
		return true;
	}

	//Suspends all header activity
	void Spirit_Suspend()
	{
		Global[GLOBAL_SUSPEND] = true;
	}

	//Resumes header activity
	void Spirit_Resume()
	{
		Global[GLOBAL_SUSPEND] = false;
	}

	//Toggles the Header suspension command on and off
	void Spirit_ToggleSuspend()
	{
		Global[GLOBAL_SUSPEND] = !Global[GLOBAL_SUSPEND];
	}
	
	//Returns true if the header is suspended
	bool Spirit_IsSuspended()
	{
		return Global[GLOBAL_SUSPEND];
	}

	//Returns if the spirit is alive as identified by the header.
	bool Spirit_IsAlive(lweapon spirit)
	{
		if(Spirit_IsSpiritLW(spirit))
			return (spirit->Misc[LWMISC_FLAGS]&LWF_ALIVE);
		else
			return false;
	}

	//Kills a Spirited weapon.
	void Spirit_Kill(lweapon spirit)
	{
		if(Spirit_IsSpiritLW(spirit))
			spirit->Misc[LWMISC_FLAGS] &= ~LWF_ALIVE;
	}

	//Revive a Spirited weapon.
	void Spirit_Revive(lweapon spirit)
	{
		if(Spirit_IsSpiritLW(spirit))
			spirit->Misc[LWMISC_FLAGS] |= LWF_ALIVE;
	}
	
	//Launches the weapon into the air, taking into account how Step and Jump interact with the Y Axis in Sideview and when Fake Z is set. To instead simply adjust the weapon, pass the weapon's step speed and their jump into the latter two args.
	//This only changes step and jump in Sideview screens. If you don't plan on using sideview screens in your quest or you may leave this out.
	//Be sure to use WrapAngle() on the weapon's angle first!
	void Spirit_AirAdjust(lweapon spirit, int step, float jump)
	{
		if(IsSideview())
		{
			--spirit->Y;
			//Obtain the difference between angles
			float difference = spirit->Angle >= RAD_DIR_LEFT ? Abs(spirit->Angle-PI*1.5) : Abs(spirit->Angle-PI/2);
			printf("Weapon Angle: %f.\nDifference from vertical angle: %f.\n", spirit->Angle, difference);
			
			//Calculate the step speed and jump mods needed to make and apply them to step speed
			spirit->Step = (step/(PI/2)*difference);
			spirit->Jump = spirit->Angle > RAD_DIR_LEFT ? (step-(step/(PI/2)*difference))/100 : -1*(step-(step/(PI/2)*difference))/100;
			printf("New Step: %i.\nNew Jump: %f.\n", spirit->Step, spirit->Jump);
			
			//Snap the spirit's angle to Left or Right depending on its angle
			if(spirit->Angle > RAD_DIR_UP || spirit->Angle < RAD_DIR_DOWN) //spirit going right
				spirit->Angle = RAD_DIR_RIGHT;
			else if(spirit->Angle < RAD_DIR_UP || spirit->Angle > RAD_DIR_DOWN) //spirit going left
				spirit->Angle = RAD_DIR_LEFT;
			printf("New Angle: %f.\n", spirit->Angle);
		}
	}

	//Returns true if the LWeapon passed is an LWeapon identified as a Spirit LWeapon by this header.
	bool Spirit_IsSpiritLW(lweapon spirit)
	{
		return (spirit->Misc[LWMISC_FLAGS_INT]&LWFI_ISSPIRIT);
	}

	//Ends scripted control over a weapon as opposed to simply killing or removing it.
	void Spirit_EndControl(lweapon spirit)
	{
		if(Spirit_IsSpiritLW(spirit))
		{
			spirit->Misc[LWMISC_FLAGS_INT] &= ~LWFI_ISSPIRIT;
			spirit->CollDetection = true;
			spirit->Script = 0;
		}
	}

	//Almost identical to the Collision function from std.zh, but slight adjustments are made to make it more accurate.
	//This function does the same thing as the Fixed Collision functions, but they are currently not included in std.zh.
	//Checks for collision between a LWeaon hitbox and the hitbox of an NPC.
	//start FixedCollision
	bool FixedCollision(lweapon a, npc b)
	{
		int ax = a->X + a->HitXOffset;
		int bx = b->X + b->HitXOffset;
		int ay = a->Y + a->HitYOffset;
		int by = b->Y + b->HitYOffset;
		return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, bx+1, by+1, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
	}

	//Collision between the hitboxes of an LWeapon and an EWeapon
	bool FixedCollision(lweapon a, eweapon b)
	{
		int ax = a->X + a->HitXOffset;
		int bx = b->X + b->HitXOffset;
		int ay = a->Y + a->HitYOffset;
		int by = b->Y + b->HitYOffset;
		return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, bx+1, by+1, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
	}

	//Collision between the hitboxes of an LWeapon and another LWeapon
	bool FixedCollision(lweapon a, lweapon b)
	{
		int ax = a->X + a->HitXOffset;
		int bx = b->X + b->HitXOffset;
		int ay = a->Y + a->HitYOffset;
		int by = b->Y + b->HitYOffset;
		return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, bx+1, by+1, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
	}

	//Checks for collision between a LWeaon hitbox and the hitbox of an Item.
	bool FixedCollision(lweapon a, item b)
	{
		int ax = a->X + a->HitXOffset;
		int bx = b->X + b->HitXOffset;
		int ay = a->Y + a->HitYOffset;
		int by = b->Y + b->HitYOffset;
		return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, bx+1, by+1, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
	}

	//Collision between the hitboxes of an LWeapon and a FFC
	bool FixedCollision(lweapon a, ffc b)
	{
		int ax = a->X + a->HitXOffset;
		int ay = a->Y + a->HitYOffset;
		return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, b->X+1, b->Y+1, b->X+b->EffectWidth-1, b->Y+b->EffectHeight-1);
	}

	bool FixedCollision(lweapon a)
	{
		int ax = a->X + a->HitXOffset;
		int linkx = Hero->X + Hero->HitXOffset;
		int ay = a->Y + a->HitYOffset;
		int linky = Hero->Y + Hero->HitYOffset;
		return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, linkx+1, linky+1, linkx+Hero->HitWidth-1, linky+Hero->HitHeight-1) && (a->Z + a->HitZHeight >= Hero->Z) && (a->Z <= Hero->Z + Hero->HitZHeight);
	}

	//So you don't have to remember the order of the args.
	bool FixedCollision(npc a, lweapon b)
	{
		return FixedCollision(b, a);
	}
	bool FixedCollision(eweapon a, lweapon b)
	{
		return FixedCollision(b, a);
	}
	bool FixedCollision(item a, lweapon b)
	{
		return FixedCollision(b, a);
	}
	bool FixedCollision(ffc a, lweapon b)
	{
		return FixedCollision(b, a);
	}
	//end
	//start
	//Similar to Collision, but it precisely checks for collision with solid combos. This specificially checks the outer edges of the hitbox
	//Args:
	//x1 - first X coordinate of the hitbox. This should not be higher than x2
	//y1 - first Y coordinate of the hitbox. This should not be higher than y2
	//x2 - second X coordinate of the hitbox. This should not be lower than x1
	//y2 - second Y coordinate of the hitbox. This should not be lower than y2
	//skipsides - Select which sides of the hitbox you want to skip checking. Add up the following values together to produce the following results:
	//	1 - Top
	//	2 - Bottom
	//	4 - Left
	//	8 - Right
	//	Each corner will still be checked unless both of its corresponding sides are skipped.
	
	bool SolidRectCollision(int x1, int y1, int x2, int y2, int skipsides)
	{
		bool solidcoll = false;
		int curx = x1;
		int cury = y1;
		until(curx > x2 || cury > y2)
		{
			//printf("Check %i:\ncurx: %f\ncury: %f\n", counter, curx, cury);
			//Skip the sides of the hitbox specified by skipsides
			bool skip = false;
			if(cury == y1)
			{
				//Check the corners
				if(curx == x1)
				{
					if(skipsides&0101b)
						skip = true;
				}
				else if(curx == x2)
				{
					if(skipsides&1001b)
						skip = true;
				}
				//Now check the top
				else
				{
					if(skipsides&0001b)
						skip = true;
				}
			}
			if(cury == y2)
			{
				//Check the corners
				if(curx == x1)
				{
					if(skipsides&0110b)
						skip = true;
				}
				else if(curx == x2)
				{
					if(skipsides&1010b)
						skip = true;
				}
				//Now check the bottom
				else
				{
					if(skipsides&0010b)
						skip = true;
				}
			}
			//Check the left
			if(curx == x1)
			{
				if(skipsides&0100b)
					skip = true;
			}
			//Check the right
			if(curx == x2)
			{
				if(skipsides&1000b)
					skip = true;
			}
			if(Screen->isSolid(curx, cury) && !skip)
			{
				solidcoll = true;
				break;
			}
			else
			{
				//Move horizontally along the top and bottom edges of the box 
				if(cury == y1 || cury == y2)
				{
					if(curx < x2)
					{
						//Move to the next column
						curx = Min(curx+8, x2);
					}
					else
					{
						//Go down to the next row
						if(cury < y2)
						{
							curx = x1;
							cury = Min(cury+8, y2);
						}
						//Bottom right corner reached, finish looping.
						else
							break;
					}
				}
				//Move down the rows
				else
				{
					//Move to the right border
					if(curx != x2)
					{
						curx = x2;
					}
					//Move down to the next row and to the left border
					else
					{
						curx = x1;
						cury = Min(cury+8, y2);
					}
				}
			}
		}
		return solidcoll;
	}
	//end
	//A fixed version of OnSidePlatform() in std.zh. It now checks for collisison on the upper bound of the box and allows you to adjust which points on the X axis it checks.
	
	bool SidePlatformCollision(int x, int y, int xOff, int yOff, int w1, int w2, int h1, int h2)
	{
		return ((Screen->isSolid((x+xOff)+w1,(y+yOff)+h1) || Screen->isSolid((x+xOff)+w2,(y+yOff)+h1) || Screen->isSolid((x+xOff)+w1,(y+yOff)+h2) || Screen->isSolid((x+xOff)+w2,(y+yOff)+h2)) && Screen->Flags[SF_ROOMTYPE]&4);
	}
}