//External imports. These should be imported in main script file.
//import "std.zh"
//import "string.zh"
//import "stdExtra.zh"
//import "ffcscript.zh"

//Ghost weapon.zh files
import "Project scripts\GhostWeapon.zh\GhostLWMovement.zh"
import "Project scripts\GhostWeapon.zh\LinkAnimation.zh"
import "Project scripts\GhostWeapon.zh\Scripts.zh"

const int LW_GHOST = 31; //The default weapon type the script uses. Highly recommended to set this to 31-40 (one of the scripted LWeapons)
//As for now, make sure that the Script Defense (or Script Defense 1 in 2.54) of all enemies in the quest is set to (None). Support will be added to allow it to be set to other values.
const int SPT_GHOSTLW_BLANK = 44; //Used for several functions like creating invisible "hitting" weapons. Set this the number of a blank sprite in the Sprite Editor. The blank sprite must use the top left tile of a 4x4 block of empty tiles.

//Small (1x1) shadow settings
//If GHOSTLW_SHADOW_TILE is 0, small shadows will be disabled
const int GHOSTLW_SHADOW_TILE = 631;
const int GHOSTLW_SHADOW_CSET = 8;
const int GHOSTLW_SHADOW_FRAMES = 4;
const int GHOSTLW_SHADOW_ANIM_SPEED = 8;
const int GHOSTLW_SHADOW_TRANSLUCENT = 1; // 0 = No, 1 = Yes
const int GHOSTLW_SHADOW_FLICKER = 0; // 0 = No, 1 = Yes

//Large (2x2) shadow settings
// If GHOSTLW_LARGE_SHADOW_TILE is 0, large shadows will be disabled
const int GHOSTLW_LARGE_SHADOW_TILE = 631; // Top-left corner
const int GHOSTLW_LARGE_SHADOW_CSET = 8;
const int GHOSTLW_LARGE_SHADOW_FRAMES = 4;
const int GHOSTLW_LARGE_SHADOW_ANIM_SPEED = 8;
const int GHOSTLW_LARGE_SHADOW_MIN_WIDTH = 3;  // Weapons must be at least this wide
const int GHOSTLW_LARGE_SHADOW_MIN_HEIGHT = 3; // and this high to use large shadows


const int MAX_LWEAPONS = 255; //The number of LWeapons that can be on the screen at any time. This is 1 less than the total maximum tho for some reason.
const int WEAPON_VARS = 49; //The number of internal variables a weapon has. This does use the expanded list in 2.54.

//Gravity variables. Set these to their respective values in your quest file.
const float GHOSTLW_GRAVITY = 0.16;
const float GHOSTLW_TERMINALVELOCITY = 3.20;
const int GHOSTLW_JUMPINGSPRITELAYER_THRESHOLD = 255; //Used only for drawing.

const int GHOSTLW_EXPVAR_COUNT = 49; //The number of scripted variables each ghosted weapon has.
const int GHOSTLW_BUFFER_SIZE = 16; //The number of LWeapons that can be stored in the GhostWeaponBuffer

//Settings
const float GHOSTLW_SETTING_ZCVERSION = 2.52; //The version of ZC you are using. If you are using ZC 2.54 or higher, set this to 2.54 to gain access to some features exclusive to 2.54.
//Note that not this header currently does not run everything exclusive to 2.54, as to maintain compatibility with 2.50.2 and 2.53. When this header gets updated take full advantage of 2.54's features many features, constants, etc that are depreciated in 2.54 will be removed and the header will no longer be compatible with older versions of ZC.

const int GHOSTLW_SETTING_PRINTERRORS = 1; //Wherever to enable error messages. 0 = Disable, 1 = Enable.

const int GHOSTLW_SETTING_FAKE_Z = 0; //If enabled, ghosted weapons never travel on the Z axis. When they would travel on the Z axis in non-sideview screens, the height effect is faked by manipulating their Y value. 0 = Disabled, 1 = Enabled.
const int GHOSTLW_SETTING_FIXBOMBS = 1; //If enabled, Link's bombs can hurt him even if the quest rule "Link's Bombs Hurt Link" is disabled. This is to fix a quirk in the way bomb explosion damage works if set via script. 0 = Disabled, 1 = Enabled.

//These settings affect how much processing is needed per frame.
const int GHOSTLW_SETTING_MAXITEM = 143; //143 is default item maximum. Add more if you add many more items.
const int GHOSTLW_SETTING_MAXITEMCLASS = 89; //The number of default item classes. Increase this if you are using any of the zz### item classes.

int GHOSTLW_GLOBAL[20]; //A series of global variables for the header to use.
//
const int GHOSTLW_GLOBAL_SUSPEND = 0; //Wherever the global section of the script is suspended or not. 0 = no, 1 = yes

const int GHOSTLW_HIT_MAXCOOLDOWN = 4; //Maximum Time, in frames, ghosted LWeapons can not hit again after hitting a target once. This is done to reduce the chance of hitting LWeapons flooding the screen from repeated enemy attacks.
//Cooldown can be increased or decreased based on how fast it is going.
//Cooldown timer begins to decrease if Step >= 400
//Cooldown timer begins to increase if Step <= 100
const int __GHOSTLW_HITWEAPON_DUR = 1; //How long hitting LWeapons persist.

//Link Tile Modifier values for items.
//This is done this way to minimize the amount of processing required.
int LTM_ITEMS[41] = {
0,
8, -12, IC_SHIELD, 2,
37, -6, IC_SHIELD, 3
};
//Each row represents a set of an item and its Link Tile Modifier
//First Row: Total Link Item Modifier
//Second Row onwards:
//First column = Item ID for Link Tile Modifier. Link needs to collect this item to activate the LTM of this row.
//Second column = Link Tile Modifier value, as in the item editor.
//Third column = Item Class, as in the item editor.
//Fourth column = Item Level, as in the item editor.

//If two or more items are from the same item class, the higher-levelled item takes precedence. If two or more items are of the same class and level, the one with the higher ID takes precedence

//LWeapon Misc[] entries. Set so they don't conflict with existing scripts
const int LWMISC_COUNTER = 14; //The weapon's internal counter. This counts upwards every frame. By default, it is restricted for use by only weapons controlled by this header; but you can remove the restriction so it applies to all weapons.
const int LWMISC_SCRIPTID = 15; //The weapon's scripted ID, so it can receive ghosted effects from the header. All Misc[] variables except this one can be used by non-ghosted weapons.

//NPC Misc[] entries. Set so they don't conflict with existing scripts.
const int NPCMISC_INVINCIBILITY = 11; //Depreciated in 2.54. Kept in for compatibility with 2.53 and earlier.
const int NPCMISC_STATUS = 12; //Keeps track of scripted NPC status afflictions. NOTE that each NPC can only have one status at a time.
const int NPCMISC_STATUS_STRENGTH = 13; //How strong the affliction is.
const int NPCMISC_STATUS_DURATION = 14; //Affliction duration.

//New Defense type constants. These are declared in 2.54's std.zh, so remove these constants from this script file so you don't get compile errors.
//These are usable in 2.52 in the extended defenses (when they are set up). Otherwise, you probably shouldn't actually use those for now
const int NPCDT_BLOCK10         = 15; //If damage is less than 10
const int NPCDT_DOUBLE          = 16;  //Double damage
const int NPCDT_TRIPLE          = 17;  //Triple Damage
const int NPCDT_QUADRUPLE       = 18;  //4x damage
const int NPCDT_HEAL            = 19;  //recover the weapon damage in HP
const int NPCDT_TRIGGERSECRETS  = 20; //Triggers all screen secrets.
const int NPCDT_FREEZE          = 21; //Freeze solid--not finished.

//Constants
float GhostWeaponExpVars[12545]; //An expanded list of Ghost LWeapon variables, accessible via script.
//Array size is (MAX_LWEAPONS+1)*GHOSTLW_EXPVAR_COUNT+1
//Note that the number at the end is not meant to be accessed through loading weapons - It's meant to keep track of weapons

//Constants for expanded variables. Note that these constants are not capitalized. Legal numbers are between 0 and GHOSTLW_EXPVAR_COUNT-1.
//Used for accessing indices in the GhostWeaponExpVars.
const int GhostLW_UID 			= 0; //Unique ID that is assigned to every weapon created by GhostWeapon.
const int GhostLW_Flags			= 1; //The scripted flags the weapon has.
const int GhostLW_X 			= 2; //The ghosted X position of the LWeapon.
const int GhostLW_Y 			= 3; //The ghosted Y position of the LWeapon.
const int GhostLW_Z				= 4; //The ghosted Z position of the LWeapon. Note that this is set even if "GHOSTLW_SETTING_FAKE_Z" is set to 1.
const int GhostLW_Jump			= 5; //The ghosted Jump variable.
const int GhostLW_Sprite 		= 6; //Ghost Weapon's original sprite.
const int GhostLW_Defense 		= 7; //The enemy defense the LWeapon hits.
const int GhostLW_Trigger 		= 8; //The combo flag the weapon checks for to trigger.
const int GhostLW_Combo 		= 9; //The combo type the weapon interacts with.
const int GhostLW_Combo_Arg 	= 10; //An arg that determines how the weapon interacts with the combo type.
const int GhostLW_Move 			= 11; //The weapon's movement type.
const int GhostLW_Move_Arg1 	= 12; //Arg 1 for weapon movement.
const int GhostLW_Move_Arg2 	= 13; //Arg 2 for weapon movement.
const int GhostLW_Lifespan 		= 14; //Lifespan setting
const int GhostLW_Lifespan_Arg1 = 15; //Arg 1 for weapon lifespan.
const int GhostLW_Lifespan_Arg2 = 16; //Arg 2 for weapon lifespan
const int GhostLW_Lives 		= 17; //Number of times the weapon can "die", producing death effects, before losing scripted control. Overridden by some Death Types and flags.
const int GhostLW_Death 		= 18; //Weapon's death type.
const int GhostLW_Death_Sound 	= 19; //SFX that plays when weapon "dies".
const int GhostLW_Death_Arg1 	= 20; //Arg 1 for weapon death effect.
const int GhostLW_Death_Arg2 	= 21; //Arg 2 for weapon death effect.
const int GhostLW_Death_Arg3 	= 22; //Arg 3 for weapon death effect.
const int GhostLW_Hit 			= 23; //Weapon's effect type.
const int GhostLW_Hit_Arg1 		= 24; //Arg 1 for weapon effect.
const int GhostLW_Hit_Arg2 		= 25; //Arg 2 for weapon effect.
const int __GhostLW_Cooldown 	= 44; //Internal var used to keep track penetrating LWeapon cooldown.
const int __GhostLW_Flags_Int	= 45; //Internal var used to keep track of internal flags.
const int __GhostLW_Move_Work1 	= 46; //Internal var used to keep track of vars to make movement work.
const int __GhostLW_Move_Work2 	= 47; //Internal var keep track of an additional var to make some movement types work.
const int __GhostLW_Step_Memory	= 48; //Internal var used to keep the weapon's step speed in memory; preventing it from moving anywhere while the header is suspended

const int GHOSTLW_NUM_MISC_EXVARS = 1; //
const int GHOSTLW_CURPOINTER = 0; //Current LWeapon pointer position. Reduces the amount of processing CreateGhostLWeapon() has to do when assigning LWeapons to slots.
//Used for tracking what point of the index we are at, reducing the number of indexes CreateGhostLWeapon checks and to identify when to loop. This is capitalized, by the way

//LWeapon flags
const int LWF_NOFALL = 1; //Weapon does not fall.
const int LWF_SOLIDPASS = 2; //Weapon ignores solid combos. The status of this flag is overridden by LWM_WALLBOUNCE. This however, does not stop it from getting blocked by combos which block it.
const int LWF_REBOUND = 4; //If LWM_SOLIDPASS is unset or weapon hits a combo that blocks it; weapon rebounds off solid combos with a large loss to their step speed. Overridden by LWM_WALLBOUNCE
const int LWF_4WAY = 8; //Weapon's sprite is automatically set based off direction and angle. The sprites should be set on the tilepage in the following order: Up Down Left Right.
const int LWF_DIAGONAL = 16; //Weapon's sprite is automatically set in diagonal directions based off direction and angle. The sprites should be set on the tilepage in the following order: LeftUp, RightUp, LeftDown, RightDown. If LWF_4WAY is also set, these come after the Up Down Left Right sprites on the tilepage.
const int LWF_ROTATESPRITE = 32; //Weapon's sprite is rotated based on direction and angle. Overrides LWF_4WAY and LWF_DIAGONAL.
const int LWF_PIERCING = 64; //Weapon does not die or vanish after hitting an enemy
const int LWF_UNBLOCKABLE = 128; //Weapon can not be blocked by shields.
const int LWF_DUMMY = 256; //Weapon does not hit enemies and can be controlled for other purposes.

//Internal LWeapon flags
const int __LWFI_AIRBORNE = 1; //Weapon has been airborne (GhostLW_Z >= 8 or GhostLW_Jump >= 2) at least once
const int __LWFI_HASDIED = 2; //Weapon has died and out of lives.

//LWeapon movement types
const int LWM_NONE = 0;
const int LWM_VEER = 1; //Weapon accelerates in a given direction
const int LWM_DRIFT = 2; //Weapon constantly drifts in a given direction
const int LWM_REAIM = 3; //Weapon travels for x frames before reaiming.
const int LWM_SINE = 4; //Weapon moves in a sine wave
const int LWM_BOUNCE = 5; //If weapon was in the air, it bounces back up when it hits the ground.
const int LWM_HOMING = 6; //Weapon homes in on NPC
const int LWM_CHASING = 7; //Weapon chases enemy, reaiming periodically.
const int LWM_WALLBOUNCE = 8; //Weapon bounces off solid objects.
const int LWM_ORBIT = 9; //Weapon orbits Link in a clockwise motion.
const int LWM_CORBIT = 10; //Same as Orbit, but counterclockwise.
const int LWM_SWING = 11; //Weapon swings out in an arc before returning to the player.
const int LWM_CSWING = 12; //Same as Swing, but it goes in the opposite direction

//LWeapon Lifespan types
const int LWL_NONE = 0; //No special lifespan
const int LWL_TIMED = 1; //Weapon dies after set amount of time
const int LWL_NEAROBJECT = 2; //Weapon dies as it approaches objects.
const int LWL_SLOWTOHALT = 3; //Weapon slows down and dies as it's Step Speed hits 0.

//LWeapon Death types
const int LWD_NONE = 0; //Weapon does nothing.
const int LWD_EXPLODE = 1; //Weapon explodes
const int LWD_EXPLODERADIAN = 2; //Weapon explodes like in LDT_EXPLODE, but deals damage based on distance from centre and only damages for one frame instead of the standard ZC explosion
const int LWD_RETURN = 3; //Weapon returns to Link like how Boomerang or Hookshot weapons return to Link. Note that weapon does not get removed if this Death Effect occurs. It will, however, disable any movement or lifespan updates and optionally also disable hit effects.
const int LWD_SPAWN = 4; //Weapon spawns weapons from the buffer
const int LWD_REPLACE = 5; //Weapon is replaced with a weapon from the buffer
const int LWD_RUNSCRIPT = 6; //Weapon runs an FFC script

//LWeapon Hit types
const int LWH_NONE = 0; //No special effects

float GhostWeaponBuffer[1552]; //GHOSTLW_BUFFER_SIZE*((GHOSTLW_EXPVAR_COUNT-1)+WEAPON_VARS) - Store LWeapons in this buffer for later usage. Used in the Spawn Death effect.
//Accessed with GhostLW_SaveToBuffer(), GhostLW_CreateFromBuffer() and through arguments for the Spawn and Replace Death Types

//Constants
const int LWEAPON_VARIABLE_BEHIND = 0;
const int LWEAPON_VARIABLE_ID = 1;
const int LWEAPON_VARIABLE_DRAWSTYLE = 2;
const int LWEAPON_VARIABLE_ORIGINALTILE = 3;
const int LWEAPON_VARIABLE_ORIGINALCSET = 4;
const int LWEAPON_VARIABLE_FLASHCSET = 5;
const int LWEAPON_VARIABLE_NUMFRAMES = 6;
const int LWEAPON_VARIABLE_ASPEED = 7;
const int LWEAPON_VARIABLE_DAMAGE = 8;
const int LWEAPON_VARIABLE_STEP = 9;
const int LWEAPON_VARIABLE_COLLDETECTION = 10;
const int LWEAPON_VARIABLE_FLASH = 11;
const int LWEAPON_VARIABLE_EXTEND = 12;
const int LWEAPON_VARIABLE_TILEWIDTH = 13;
const int LWEAPON_VARIABLE_TILEHEIGHT = 14;
const int LWEAPON_VARIABLE_HITWIDTH = 15;
const int LWEAPON_VARIABLE_HITHEIGHT = 16;
const int LWEAPON_VARIABLE_HITZHEIGHT = 17;
const int LWEAPON_VARIABLE_MISC0 = 18;
const int LWEAPON_VARIABLE_MISC1 = 19;
const int LWEAPON_VARIABLE_MISC2 = 20;
const int LWEAPON_VARIABLE_MISC3 = 21;
const int LWEAPON_VARIABLE_MISC4 = 22;
const int LWEAPON_VARIABLE_MISC5 = 23;
const int LWEAPON_VARIABLE_MISC6 = 24;
const int LWEAPON_VARIABLE_MISC7 = 25;
const int LWEAPON_VARIABLE_MISC8 = 26;
const int LWEAPON_VARIABLE_MISC9 = 27;
const int LWEAPON_VARIABLE_MISC10 = 28;
const int LWEAPON_VARIABLE_MISC11 = 29;
const int LWEAPON_VARIABLE_MISC12 = 30;
const int LWEAPON_VARIABLE_MISC13 = 31;
const int LWEAPON_VARIABLE_MISC14 = 32;
const int LWEAPON_VARIABLE_MISC15 = 33;

//These are 2.54-exclusive Misc Variables. Attempting to use them in 2.53 or lower is a *BAD* idea. Currently, these are untested and will be tested only when working in 2.54
const int LWEAPON_VARIABLE_MISC16 = 34;
const int LWEAPON_VARIABLE_MISC17 = 35;
const int LWEAPON_VARIABLE_MISC18 = 36;
const int LWEAPON_VARIABLE_MISC19 = 37;
const int LWEAPON_VARIABLE_MISC20 = 38;
const int LWEAPON_VARIABLE_MISC21 = 39;
const int LWEAPON_VARIABLE_MISC22 = 40;
const int LWEAPON_VARIABLE_MISC23 = 41;
const int LWEAPON_VARIABLE_MISC24 = 42;
const int LWEAPON_VARIABLE_MISC25 = 43;
const int LWEAPON_VARIABLE_MISC26 = 44;
const int LWEAPON_VARIABLE_MISC27 = 45;
const int LWEAPON_VARIABLE_MISC28 = 46;
const int LWEAPON_VARIABLE_MISC29 = 47;
const int LWEAPON_VARIABLE_MISC30 = 48;
const int LWEAPON_VARIABLE_MISC31 = 49;


//End of settings

//Imports
//

//Updates the Ghosted weapons 
void GhostWeapon_Update(){
	for(int i = 1; i <= Screen->NumLWeapons(); i ++){ //Iterates over all ghosted LWeapons once per frame
		lweapon weapon = Screen->LoadLWeapon(i);
		//Weapon checks out as being a ghosted LWeapon, do script stuff to it
		if(weapon->ID == LW_GHOST){
			if(weapon->Misc[LWMISC_SCRIPTID] == -1 && weapon->Misc[LWMISC_COUNTER] >= __GHOSTLW_HITWEAPON_DUR){
				Remove(weapon);
			}
			weapon->Misc[LWMISC_COUNTER] ++;
			if(weapon->Misc[LWMISC_SCRIPTID] >= 1 && weapon->Misc[LWMISC_SCRIPTID] <= 256){
				//LWeapon updates are suspended.
				if(GHOSTLW_GLOBAL[GHOSTLW_GLOBAL_SUSPEND] == 1){
					if(weapon->Step > 0){
						SetGhostLWData(weapon, __GhostLW_Step_Memory, weapon->Step);
						weapon->Step = 0;
					}
					continue;
				}
				int cooldown = GetGhostLWData(weapon, __GhostLW_Cooldown);
				if(cooldown > 0){
					SetGhostLWData(weapon, __GhostLW_Cooldown, cooldown-1);
				}
				UpdateGhostLWMovement(weapon);
				//Weapon strays too far offscreen; kill it.
				if(weapon->X < SCREEN_WIDTH*-1 || weapon->X > SCREEN_WIDTH*2 || weapon->Y < SCREEN_HEIGHT*-1 || weapon->Y > SCREEN_HEIGHT*2){
					KillGhostLWeapon(weapon, true, true);
					return;
				}
				for(int nme = 1; nme <= Screen->NumNPCs(); nme ++){
					npc target = Screen->LoadNPC(nme);
					if(GhostLWCollision(weapon, target) && target->Misc[NPCMISC_INVINCIBILITY] <= 0){
						if(GetGhostLWData(weapon, __GhostLW_Cooldown) <= 0){
							__CreateHittingLWeapon(weapon, target);
							SetGhostLWData(weapon, __GhostLW_Cooldown, GHOSTLW_HIT_MAXCOOLDOWN);
							//Kill Ghosted weapon after hitting unless it has the appropriate flags.
							if((GetGhostLWData(weapon, GhostLW_Flags)&LWF_PIERCING) == 0){ //Not piercing; kill and remove weapon
									KillGhostLWeapon(weapon, true, false);
							}
						}
					}
				}
			}
		}
	}
}

//Called in the main loop after Waitdraw();
void GhostWeapon_Draw(){
	for(int wpn = 1; wpn <= Screen->NumLWeapons(); wpn ++){
		lweapon weapon = Screen->LoadLWeapon(wpn);
		if(IsGhostedLWeapon(weapon)){
			int drawx = GetGhostLWData(weapon, GhostLW_X);
			int drawy = GetGhostLWData(weapon, GhostLW_Y);
			int drawz = GetGhostLWData(weapon, GhostLW_Z);
			//Draws shadows
			if(drawz > 0){
				if(GHOSTLW_SHADOW_TILE > 0){
					if(!IsSideview()){
						Screen->FastTile(0, drawx, drawy, GhostLW_GetCurrentTile(GHOSTLW_SHADOW_TILE, GHOSTLW_SHADOW_FRAMES, GHOSTLW_SHADOW_ANIM_SPEED, weapon->Misc[LWMISC_COUNTER]), GHOSTLW_SHADOW_CSET, OP_TRANS);
					}
				}
			}
		}
	}
}

//Start by clearing all relevant arrays.
void GhostWeapon_Start(){
	memset(GhostWeaponExpVars, 0, SizeOfArray(GhostWeaponExpVars));
	memset(GhostWeaponBuffer, 0, SizeOfArray(GhostWeaponBuffer));
}

int GhostLW_GetCurrentTile(int tile, int animframes, int animspeed, int counter){
	int curanimframe = counter/animspeed;
	int curanimtile = curanimframe%animframes;
	return tile+curanimtile;
}

//An auxiliary function used to update enemy invincibility frames among other NPC parameters. Some parts are depreciated in 2.54
void GhostWeapon_UpdateEnemyParameters(){
	for(int nme = 1; nme <= Screen->NumNPCs(); nme ++){
		npc target = Screen->LoadNPC(nme);
		if(target->Misc[NPCMISC_INVINCIBILITY] > 0){
			target->Misc[NPCMISC_INVINCIBILITY] --;
		}
	}
}

//Creates a ghosted LWeapon with basic settings. The weapon can have different movement, lifespan, death and hit effects set to it through the appropriate functions.
//Overloaded to make placing it on the Z axis optional.
lweapon CreateGhostLWeapon(int x, int y, int z, int damage, int defense, int direction, int speed, int sprite, int sound, int trigger, int combo, int comboarg, int flags){
	lweapon weapon = CreateLWeaponAt(LW_GHOST, x, y);
	bool hasreloaded = false; //Have the weapon slots been reloaded yet?
	for(int slot = GetGhostLWData(0, GHOSTLW_CURPOINTER)+1; slot <= MAX_LWEAPONS+1; slot ++){ //Search for a free script weapon slot.
		if(GetGhostLWData(slot, GhostLW_UID) < 1){ //Free slot found. Assign weapon to that slot
			__AssignGhostLWeaponSlot(weapon, slot, sprite, defense, flags, trigger, combo, comboarg);
			if(z > 0){
				SetGhostLWData(weapon, GhostLW_Z, z);
			}
			weapon->Step = speed;
			weapon->Damage = damage;
			weapon->CollDetection = false;
			weapon->Angular = true;
//			Trace(GetGhostLWData(slot, GhostLW_UID)); 
//			Trace(GhostWeaponExpVars[(slot-1)*GHOSTLW_EXPVAR_COUNT]); 
			weapon->Angle = DegtoRad(GhostLWAngleOrDir(direction));
			weapon->Dir = AngleDir8(RadtoDeg(weapon->Angle));
			if(sound > 0){
				Game->PlaySound(sound);
			}
			break;
		}
//		Trace(GetGhostLWData(0, GHOSTLW_CURPOINTER));
		SetGhostLWData(0, GHOSTLW_CURPOINTER, GetGhostLWData(0, GHOSTLW_CURPOINTER) + 1);
		if(slot == MAX_LWEAPONS+1){ //Free slot not found, go through the array and reload scripted weapons.
			Trace(9001);
			if(!hasreloaded){
				__ReloadScriptWeapons();
				SetGhostLWData(0, GHOSTLW_CURPOINTER, 0);
				slot = 0; //Set to 0 because it will increment at the end of this iteration. slot will be equal to 1 next iteration.
				hasreloaded = true;
			}
			else{ //Free slot STILL not found? Return an error message.
				SetGhostLWData(0, GHOSTLW_CURPOINTER, MAX_LWEAPONS);
				GhostWeapon_PrintErrorMSG(0, 2);
			}
		}
	}
	return weapon;
}

lweapon CreateGhostLWeapon(int x, int y, int damage, int defense, int direction, int speed, int sprite, int sound, int trigger, int combo, int comboarg, int flags){
	return CreateGhostLWeapon(x, y, 0, damage, defense, direction, speed, sprite, sound, trigger, combo, comboarg, flags);
}

void __AssignGhostLWeaponSlot(lweapon weapon, int slot, int sprite, int defense, int flags, int trigger, int combo, int comboarg){ //Sets up a ghosted weapon slot. Called internally in CreateGhostLWeapon.
	//Slot is free, slot is valid and the weapon passed is LW_GHOST
	if(GetGhostLWData(slot, GhostLW_UID) < 1 && (slot >= 1 && slot <= MAX_LWEAPONS+1) && weapon->ID == LW_GHOST){
		//Assign the weapon to the slot and its related script vars
		RefreshGhostLWeaponSlot(slot);
		weapon->Misc[LWMISC_SCRIPTID] = slot;
		SetGhostLWData(weapon, GhostLW_UID, slot);
		SetGhostLWData(weapon, GhostLW_Flags, flags);
		SetGhostLWData(weapon, GhostLW_X, weapon->X);
		SetGhostLWData(weapon, GhostLW_Y, weapon->Y);
		SetGhostLWData(weapon, GhostLW_Sprite, sprite);
		weapon->UseSprite(sprite);
		SetGhostLWData(weapon, GhostLW_Defense, defense);
		SetGhostLWData(weapon, GhostLW_Trigger, trigger);
		SetGhostLWData(weapon, GhostLW_Combo, combo);
		SetGhostLWData(weapon, GhostLW_Combo_Arg, comboarg);
	}
	else{//Error messages
		if(GetGhostLWData(slot, GhostLW_UID) > 0){ //Slot is not free
			GhostWeapon_PrintErrorMSG(0, 3, slot);
		}
		if(slot < 1 && slot > MAX_LWEAPONS+1){ //Slot is not valid
			GhostWeapon_PrintErrorMSG(0, 3, slot);
		}
		if(weapon->ID != LW_GHOST){ //Not suitable weapon
			GhostWeapon_PrintErrorMSG(0, 3);
		}
	}
}

//Returns either one of the eight cardinal directions (U D L R UL UR DL DR) or an angle.
//direction is 0-7: cardinal direction
//direction is below 0: Angle
int GhostLWAngleOrDir(int direction){ 
	if(direction >= 0 && direction < 8){
		return WrapDegrees(GhostLW8dirToDeg(direction));
	}
	//Negative Dir, use angle instead.
	else if(direction < 0){
		return WrapDegrees(Abs(VBound(direction, -1, -360)) - 1);
	}
}

//Returns if this weapon is to obey sideview gravity

//Gets GhostLW data for index parameter in slot slot. The slot must be in use.
//Pass 0 to slot to instead read from miscellaneous vars in the array.
float GetGhostLWData(int slot, int index){
	if(slot >= 1 && slot <= MAX_LWEAPONS+1 && (index >= 0 && index < GHOSTLW_EXPVAR_COUNT)){ //Valid slot and slot in use
		return GhostWeaponExpVars[((slot-1)*GHOSTLW_EXPVAR_COUNT)+index];
	}
	else if(slot == 0 && (index >= 0 && index < GHOSTLW_NUM_MISC_EXVARS)){
		return GhostWeaponExpVars[((MAX_LWEAPONS+1)*GHOSTLW_EXPVAR_COUNT)+index];
	}
	else{ //Return -1 and print an error message
		if(GhostWeaponExpVars[((slot-1)*GHOSTLW_EXPVAR_COUNT)+GhostLW_UID] < 0){ //Slot not in use
			GhostWeapon_PrintErrorMSG(1, 0, slot);
		}
		else{ //Invalid slot
			GhostWeapon_PrintErrorMSG(1, 1, slot);
		}
		return -1;
	}
}

//Same as above, but takes an LWeapon as its arg
float GetGhostLWData(lweapon weapon, int index){
	if(weapon->ID == LW_GHOST && weapon->Misc[LWMISC_SCRIPTID] >= 1 && weapon->Misc[LWMISC_SCRIPTID] <= MAX_LWEAPONS+1){ //Is Ghosted weapon.
		return GhostWeaponExpVars[GetGhostLWDataLocation(weapon->Misc[LWMISC_SCRIPTID], index)];
	}
	else{ //Is not ghosted weapon
		if(weapon->ID != LW_GHOST){ //Not suitable weapon type
			GhostWeapon_PrintErrorMSG(1, 2);
		}
		else{ //Not flagged as ghosted.
			GhostWeapon_PrintErrorMSG(1, 3);
		}
		return -1;
	}
}

//Returns the location of where the array is pointing to; based off slot and index. Otherwise, rules are the same as above
float GetGhostLWDataLocation(int slot, int index){
	if(slot >= 1 && slot <= MAX_LWEAPONS+1 && (index >= 0 && index < GHOSTLW_EXPVAR_COUNT)){ //Valid slot and slot in use
		return ((slot-1)*GHOSTLW_EXPVAR_COUNT)+index;
	}
	else if(slot == 0 && (index >= 0 && index < GHOSTLW_NUM_MISC_EXVARS)){
		return ((MAX_LWEAPONS+1)*GHOSTLW_EXPVAR_COUNT)+index;
	}
	else{ //Return -1 and print an error message
		GhostWeapon_PrintErrorMSG(1, 1, slot);
		return -1;
	}
}

//Same as above, but takes an LWeapon as its arg
float GetGhostLWDataLocation(lweapon weapon, int index){
	if(weapon->ID == LW_GHOST && weapon->Misc[LWMISC_SCRIPTID] >= 1 && weapon->Misc[LWMISC_SCRIPTID] <= MAX_LWEAPONS+1){ //Is Ghosted weapon.
		return GetGhostLWDataLocation(weapon->Misc[LWMISC_SCRIPTID], index);
	}
	else{ //Is not ghosted weapon
		if(weapon->ID != LW_GHOST){ //Not suitable weapon type
			GhostWeapon_PrintErrorMSG(1, 2);
		}
		else{ //Not flagged as ghosted.
			GhostWeapon_PrintErrorMSG(1, 3);
		}
		return -1;
	}
}

//Sets GhostLW data for index parameter in slot slot
void SetGhostLWData(int slot, int index, float value){
	if(slot >= 1 && slot <= MAX_LWEAPONS+1 && (index >= 0 && index < GHOSTLW_EXPVAR_COUNT)){ //Valid slot and slot in use.
		GhostWeaponExpVars[((slot-1)*GHOSTLW_EXPVAR_COUNT)+index] = value;
	}
	else if(slot == 0 && (index >= 0 && index < GHOSTLW_NUM_MISC_EXVARS)){
		GhostWeaponExpVars[((MAX_LWEAPONS+1)*GHOSTLW_EXPVAR_COUNT)+index] = value;
	}
	else{ //Return -1 and print an error message
		if(GhostWeaponExpVars[((slot-1)*GHOSTLW_EXPVAR_COUNT)+GhostLW_UID] < 0){ //Slot not in use
			GhostWeapon_PrintErrorMSG(1, 0, slot);
		}
		else{ //Invalid slot
			GhostWeapon_PrintErrorMSG(1, 1, slot);
		}
	}
}


//Same as above, but actively sets the data for an already existing weapon.
void SetGhostLWData(lweapon weapon, int index, float value){
	if(weapon->ID == LW_GHOST && weapon->Misc[LWMISC_SCRIPTID] >= 1 && weapon->Misc[LWMISC_SCRIPTID] <= MAX_LWEAPONS+1){ //Is Ghosted weapon.
		SetGhostLWData(weapon->Misc[LWMISC_SCRIPTID], index, value);
	}
	else{ //Is not ghosted weapon
		if(weapon->ID != LW_GHOST){ //Not suitable weapon type
			GhostWeapon_PrintErrorMSG(1, 2);
		}
		else{ //Not flagged as ghosted.
			GhostWeapon_PrintErrorMSG(1, 3);
		}
	}
}

void __ReloadScriptWeapons(){ //Reloads scripted weapons.
	//First, reset the ExpVar ID slots.
	SetGhostLWData(0, GHOSTLW_CURPOINTER, 0); //Reset the current pointer.
	for(int slot = 1; slot <= MAX_LWEAPONS+1; slot ++){
		SetGhostLWData(slot, GhostLW_UID, 0);
	}
	//Now, go over any existing weapons and plug their IDs back in
	for(int wep = 1; wep <= Screen->NumLWeapons(); wep ++){
		lweapon weapon = Screen->LoadLWeapon(wep);
		if(weapon->Misc[LWMISC_SCRIPTID] >= 1 && weapon->Misc[LWMISC_SCRIPTID] <= 256){ //Valid script ID
			if(GetGhostLWData(weapon, GhostLW_UID) == 0){ //Check to see if the script ID entry is free
				SetGhostLWData(weapon, GhostLW_UID, weapon->Misc[LWMISC_SCRIPTID]);
			}
		}
	}
}

void ClearGhostLWeapon(lweapon weapon){ //Clears the data from one ghosted LWeapon and removes the weapon.
	memset(GhostWeaponExpVars, (weapon->Misc[LWMISC_SCRIPTID]-1)*GHOSTLW_EXPVAR_COUNT, 0, GHOSTLW_EXPVAR_COUNT);
	Remove(weapon);
}

void RefreshGhostLWeaponSlot(int slot){ //As above, but it clears a slot instead without removing the weapon. Also called internally to refresh a slot in case the data did not get cleared.
	memset(GhostWeaponExpVars, (slot-1)*GHOSTLW_EXPVAR_COUNT, 0, GHOSTLW_EXPVAR_COUNT);
}

void ClearAllGhostLWeapons(bool kill){ //Purges all ghosted LWeapon data. If kill is true, all scripted LWeapons are also removed.
	memset(GhostWeaponExpVars, 0, SizeOfArray(GhostWeaponExpVars));
	if(kill){ //Also kill weapons
		for(int wpn = 1; wpn <= Screen->NumLWeapons(); wpn ++){
			lweapon weapon = Screen->LoadLWeapon(wpn);
			if(weapon->Misc[LWMISC_SCRIPTID] > 0){
				Remove(weapon);
			}
		}
	}
}

//Stores data of an LWeapon to a slot in the buffer
void SaveToBuffer(lweapon weapon, int slot, bool remove){
}

lweapon CreateFromBuffer(int slot, int x, int y){ //Creates an LWeapon using data from the buffer. slot corresponds to which slot it reads from.
}

void ClearBufferSlot(int slot){ //Clears a slot in the buffer
}

void ClearBuffer(){ //Clears the whole buffer.
}

//Suspends all ghosted LWeapons.
void SuspendGhostLWeapon(){
	if(GHOSTLW_GLOBAL[GHOSTLW_GLOBAL_SUSPEND] == 1){
		return;
	}
	for(int wpn = 1; wpn <= Screen->NumLWeapons(); wpn ++){
		lweapon weapon = Screen->LoadLWeapon(wpn);
		if(IsGhostedLWeapon(weapon)){
			if(weapon->Step > 0){
				SetGhostLWData(weapon, __GhostLW_Step_Memory, weapon->Step);
				weapon->Step = 0;
			}
		}
	}
	GHOSTLW_GLOBAL[GHOSTLW_GLOBAL_SUSPEND] = 1;
}

//Resumes ghosted weapon activity
void ResumeGhostLWeapon(){
	if(GHOSTLW_GLOBAL[GHOSTLW_GLOBAL_SUSPEND] == 0){
		return;
	}
	for(int wpn = 1; wpn <= Screen->NumLWeapons(); wpn ++){
		lweapon weapon = Screen->LoadLWeapon(wpn);
		if(IsGhostedLWeapon(weapon)){
			if(GetGhostLWData(weapon, __GhostLW_Step_Memory) > 0){
				weapon->Step = GetGhostLWData(weapon, __GhostLW_Step_Memory);
				SetGhostLWData(weapon, __GhostLW_Step_Memory, 0);
			}
		}
	}
	__ReloadScriptWeapons();
	GHOSTLW_GLOBAL[GHOSTLW_GLOBAL_SUSPEND] = 0;
}

//Sets ghosted weapon movement
void SetGhostLWeaponMovement(lweapon weapon, int type, int arg1, int arg2){ 
	if(IsGhostedLWeapon(weapon)){
		SetGhostLWData(weapon, GhostLW_Move, type);
		SetGhostLWData(weapon, GhostLW_Move_Arg1, arg1);
		SetGhostLWData(weapon, GhostLW_Move_Arg2, arg2);
	}
}

//Sets ghosted weapon lifespan.
void SetGhostLWeaponLifespan(lweapon weapon, int type, int arg1, int arg2, int lives){ 
	if(IsGhostedLWeapon(weapon)){
		SetGhostLWData(weapon, GhostLW_Lifespan, type);
		SetGhostLWData(weapon, GhostLW_Lifespan_Arg1, arg1);
		SetGhostLWData(weapon, GhostLW_Lifespan_Arg2, arg2);
		SetGhostLWData(weapon, GhostLW_Lives, lives);
		//Bounds lives values to certain boundaries.
		if(GetGhostLWData(weapon, GhostLW_Lives) < 1){ SetGhostLWData(weapon, GhostLW_Lives, 1);}
		if(GetGhostLWData(weapon, GhostLW_Lives) > 255){ SetGhostLWData(weapon, GhostLW_Lives, 255);}
	}
}

//Overloaded to make the lives args optional.
void SetGhostLWeaponLifespan(lweapon weapon, int type, int arg1, int arg2){
	SetGhostLWeaponLifespan(weapon, type, arg1, arg2, 1);
}

//Sets ghosted weapon death effect.
void SetGhostLWeaponDeathEffect(lweapon weapon, int type, int arg1, int arg2, int arg3, int sound){ 
	if(IsGhostedLWeapon(weapon)){
		SetGhostLWData(weapon, GhostLW_Death, type);
		SetGhostLWData(weapon, GhostLW_Death_Arg1, arg1);
		SetGhostLWData(weapon, GhostLW_Death_Arg2, arg2);
		SetGhostLWData(weapon, GhostLW_Death_Arg3, arg3);
		SetGhostLWData(weapon, GhostLW_Death_Sound, sound);
	}
}

//Overloaded to make the sound arg optional
void SetGhostLWeaponDeathEffect(lweapon weapon, int type, int arg1, int arg2, int arg3){
	SetGhostLWeaponDeathEffect(weapon, type, arg1, arg2, arg3, 0);
}

void SetGhostLWeaponHitEffect(lweapon weapon, int type, int arg1, int arg2){ //Sets ghosted weapon hit effect
}

bool IsGhostedLWeapon(lweapon weapon){ //A quick check to see if a weapon is a ghosted weapon
	return(weapon->ID == LW_GHOST && weapon->Misc[LWMISC_SCRIPTID] >= 1 && weapon->Misc[LWMISC_SCRIPTID] <= MAX_LWEAPONS+1);
}

//Kills a ghosted LWeapon, removing it and producing any death effects
//weapon is LWeapon passed. overridelives determines wherever to remove the LWeapon regardless of number of lives remaining - Set to true to remove the weapon regardless of number of lives. canceleffect determines wherever it skips the death effect - Set to true to skip the death effect.
void KillGhostLWeapon(lweapon weapon, bool overridelives, bool canceleffect){
	if(IsGhostedLWeapon(weapon)){
		//First, check for the various Death Effects
		if(!canceleffect){
			int death = GetGhostLWData(weapon, GhostLW_Death);
			int deathsound = GetGhostLWData(weapon, GhostLW_Death_Sound);
			if(deathsound > 0){ 
				Game->PlaySound(deathsound);
			}
			//Explode
			if(death == LWD_EXPLODE){
				Game->PlaySound(SFX_BOMB);
				int type = GetGhostLWData(weapon, GhostLW_Death_Arg1);
				int damage = GetGhostLWData(weapon, GhostLW_Death_Arg2);
				lweapon boom = CreateLWeaponAt(LW_BOMBBLAST+type, weapon->X, weapon->Y);
				boom->Damage = damage;
				if(GHOSTLW_SETTING_FIXBOMBS == 1){
					eweapon eboom = CreateEWeaponAt(EW_BOMBBLAST+type, weapon->X, weapon->Y);
					eboom->Damage = damage;
					eboom->DrawYOffset = 2000;
				}
			}
		}
		int lives = GetGhostLWData(weapon, GhostLW_Lives);
		//Next, run the lives counter.
		if(overridelives || lives == 0){
			ClearGhostLWeapon(weapon);
		}
		else{
			SetGhostLWData(weapon, GhostLW_Lives, lives-1);
		}
	}
}

//Takes a float and strips its decimal part away.
int GhostWeapon_StripDecimal(float arg){
	return Floor(arg);
}

//Takes a float and strips the whole numbers out, leaving only decimals
float GhostWeapon_LeaveDecimal(float arg){
	int sub = arg;
	return arg - sub;
}

//Takes a float and turns its decimal part into an integer.
int GhostWeapon_DecimalToInt(float arg){
	int sub = Floor(arg);
	return (arg-sub)*10000;
}

//Takes an int and turns it into a decimal number. Can only keep the four most significant digits.
float GhostWeapon_IntToDecimal(int arg){
	float result = arg;
	int divisor = 10000;
	//Handling for larger numbers, so the four most significant digits are kept.
	if(arg >= 10000){
		divisor = 100000;
	}
	return result/divisor;
}

//Returns the highest levelled item of itemclass that is in Link's Inventory.
//A small edit of the GetHighestLevelItem from std.zh, edited so Link has to have the item in order for it to count.
int GhostLW_GetHighestLevelLinkItem(int itemclass){
	itemdata id;
	int ret = -1;
	int curlevel = -1000;
	for(int i = 0; i < GHOSTLW_SETTING_MAXITEM; i++){
		id = Game->LoadItemData(i);
		if(id->Family != itemclass || !Link->Item[i])
			continue;
		if(id->Level > curlevel && Link->Item[i]){
			curlevel = id->Level;
			ret = i;
		}
	}
	return ret;
}



 //The step where the LWeapon actually hits the target and does damage. Called internally in GhostWeaponUpdate();
void __CreateHittingLWeapon(lweapon weapon, npc target){
	lweapon hit = CreateLWeaponAt(LW_GHOST, target->X, target->Y);
	hit->Damage = weapon->Damage;
	hit->Dir = weapon->Dir;
	hit->Misc[LWMISC_SCRIPTID] = -1; //Signified as a hitting weapon
	hit->UseSprite(SPT_GHOSTLW_BLANK);
	__GhostLWEmulateDefenses(hit, target, GetGhostLWData(weapon, GhostLW_Defense));
}

//This script enables a scripted LWeapon wpn to emulate the defences for built-in weapons.
void __GhostLWEmulateDefenses(lweapon wpn, npc nme, int def){
    if(nme->Defense[def] == NPCDT_HALFDAMAGE){ //Halves the LWeapon's damage.
        wpn->Damage /= 2;
    }
    else if(nme->Defense[def] == NPCDT_QUARTERDAMAGE){ //Quarters the LWeapon's damage
        wpn->Damage /= 4;
    }
    else if(nme->Defense[def] == NPCDT_STUN){ //Stuns the NPC
        wpn->Damage = 0;
        nme->Stun = 256;
    }
    else if(nme->Defense[def] == NPCDT_STUNORBLOCK){ //Stuns or blocks the LWeapon
        if(wpn->Damage >= 2){
            wpn->Damage = 0;
            nme->Stun = 256;
        }
        else{
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
    }
    else if(nme->Defense[def] == NPCDT_STUNORIGNORE){ //Stun or Ignore the NPC.
        if(wpn->Damage >= 2){
            wpn->Damage = 0;
            nme->Stun = 256;
        }
        else{
            Remove(wpn);
        }
    }
    else if(nme->Defense[def] == NPCDT_BLOCK1){ //Block if the LWeapon does 2 or less damage.
        if(wpn->Damage < 2){
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
    }
    else if(nme->Defense[def] == NPCDT_BLOCK2){ //Block if the LWeapon does 4 or less damage.
        if(wpn->Damage < 4){
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
    }
    else if(nme->Defense[def] == NPCDT_BLOCK4){ //Block if the LWeapon does 8 or less damage
        if(wpn->Damage < 8){
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
    }
    else if(nme->Defense[def] == NPCDT_BLOCK6){ //Block if the LWeapon does 12 or less damage
        if(wpn->Damage < 12){
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
    }
    else if(nme->Defense[def] == NPCDT_BLOCK8){ //Block if the LWeapon does 16 or less damage
        if(wpn->Damage < 16){
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
    }
    else if(nme->Defense[def] == NPCDT_BLOCK){ //Blocks the LWeapon outright.
        Remove(wpn);
        Game->PlaySound(SFX_CLINK);
    }
    else if(nme->Defense[def] == NPCDT_IGNORE1){ //The LWeapon ignores the NPC if it would do 2 or less damage.
        if(wpn->Damage < 2){
            Remove(wpn);
        }
    }
    else if(nme->Defense[def] == NPCDT_IGNORE){ //The LWeapon outright ignores the NPC.
        Remove(wpn);
    }
    else if(nme->Defense[def] == NPCDT_ONEHITKILL){ //The LWeapon OHKOs the NPC.
        wpn->Damage = nme->HP;
    }
	//Extra defense types. These work as they work in 2.54, but the scripted defenses can use these in 2.52
	else if(nme->Defense[def] == NPCDT_BLOCK10){ //LWeapon does 10 or less damage
        if(wpn->Damage < 10){
            Remove(wpn);
            Game->PlaySound(SFX_CLINK);
        }
	}
    else if(nme->Defense[def] == NPCDT_DOUBLE){ //The LWeapon does x2 damage to the NPC.
        wpn->Damage *= 2;
    }
    else if(nme->Defense[def] == NPCDT_TRIPLE){ //The LWeapon does x3 damage to the NPC.
        wpn->Damage *= 3;
    }
    else if(nme->Defense[def] == NPCDT_QUADRUPLE){ //The LWeapon does x4 damage to the NPC.
        wpn->Damage *= 4;
    }
    else if(nme->Defense[def] == NPCDT_HEAL){ //LWeapon heals the NPC.
		nme->HP += wpn->Damage;
        Remove(wpn);
    }
	else if(nme->Defense[def] == NPCDT_TRIGGERSECRETS){ //LWeapon causes NPC to trigger screen secrets.
		Screen->TriggerSecrets();
		if((Screen->Flags[SF_SECRETS]&2) == 0 && ((Screen->Flags[SF_ROOMTYPE]&2) == 0)){ //Secrets are not temporary and the screen is not a NES Dungeon type.
			Screen->State[ST_SECRET] = true;
		}
	}
	else if(nme->Defense[def] == NPCDT_FREEZE){ //Incomplete
	}
	//New defense types go here
}

//Almost identical to the Collision function from std.zh, but slight adjustments are made to make it more accurate.
//This function does the same thing as the Fixed Collision functions, but they are currently not included in std.zh.
//Checks for collision between a LWeaon hitbox and the hitbox of an NPC.
bool GhostLWCollision(lweapon a, npc b){
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, bx+1, by+1, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

//Collision between the hitboxes of an LWeapon and an EWeapon
bool GhostLWCollision(lweapon a, eweapon b){
	int ax = a->X + a->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = a->Y + a->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax+1, ay+1, ax+a->HitWidth-1, ay+a->HitHeight-1, bx+1, by+1, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}


//So you don't have to remember the order of the args.
bool GhostLWCollision(npc target, lweapon weapon){
	return GhostLWCollision(weapon, target);
}
bool GhostLWCollision(eweapon target, lweapon weapon){
	GhostLWCollision(weapon, target);
}

float GhostLW8dirToRad(int dir){
	if(dir >= 0 && dir < 4){
		return dirToRad(dir);
	}
	else if(dir >= 4 && dir < 8){
		if(dir == 4){
			return 1.25 * PI;
		}
		else if(dir == 5){
			return 1.75 * PI;
		}
		else if(dir == 6){
			return 0.75 * PI;
		}
		else if(dir == 7){
			return 0.25 * PI;
		}
	}
}

int GhostLW8dirToDeg(int dir){
	if(dir >= 0 && dir < 4){
		if(dir == DIR_UP){
			return 270;
		}
		else if(dir == DIR_DOWN){
			return 90;
		}
		else if(dir == DIR_LEFT){
			return 180;
		}
		else if(dir == DIR_RIGHT){
			return 0;
		}
	}
	else if(dir >= 4 && dir < 8){
		if(dir == 4){
			return 225;
		}
		else if(dir == 5){
			return 315;
		}
		else if(dir == 6){
			return 135;
		}
		else if(dir == 7){
			return 45;
		}
	}
}

//Debugging.
//Prints error messages to Allegro.log.
//Overloaded to make some args optional
void GhostWeapon_PrintErrorMSG(int category, int type, int a1, int a2, int a3, int a4){
	if(GHOSTLW_SETTING_PRINTERRORS == 1){ //Error printing is enabled
		int error[256] = "Error: ";
		int reason[256];
		if(category == 0){ //Failed to create ghosted weapon
			int preerror[256] = "Failed to create ghosted weapon ";
			strcat(error, preerror);
			if(type == 0){ //Slot is already occupied.
				int prereason[] = "(Slot %d is not free)";
				sprintf(reason, prereason, a1);
			}
			else if(type == 1){ //Slot does not exist.
				int prereason[] = "(Slot %d does not exist)";
				sprintf(reason, prereason, a1);
			}
			else if(type == 2){ //No slots available.
				int prereason[] = "(No available slots)";
				strcat(reason, prereason);
			}
			else if(type == 3){ //LWeapon passed is not suitable
				int prereason[] = "(LWeapon passed is not LW_GHOST)";
				strcat(reason, prereason);
			}
			else if(type == 4){ //Max amount of LWeapons on screen
				int prereason[] = "(Maximum number of LWeapons already on screen)";
				strcat(reason, prereason);
			}
		}
		else if(category == 1){ //Failed to load ghosted weapon
			int preerror[256] = "Failed to load ghosted weapon ";
			strcat(error, preerror);
			if(type == 0){ //Weapon data is not valid
				int prereason[] = "(Weapon data for slot %d is not valid)";
				sprintf(reason, prereason, a1);
			}
			else if(type == 1){ //Slot does not exist
				int prereason[] = "(Slot %d is not a valid slot)";
				sprintf(reason, prereason, a1);
			}
			else if(type == 2){ //LWeapon passed is not of suitable type
				int prereason[] = "(LWeapon passed is not LW_GHOST)";
				strcat(reason, prereason);
			}
			else if(type == 3){ //LWeapon passed is not flagged as ghosted
				int prereason[] = "(LWeapon passed is not assigned as a ghosted weapon)";
				strcat(reason, prereason);
			}
		}
		strcat(error, reason);
		TraceS(error);
		TraceNL();
	}
}

void GhostWeapon_PrintErrorMSG(int category, int type, int a1, int a2, int a3){
	GhostWeapon_PrintErrorMSG(category, type, a1, a2, a3, -1);
}

void GhostWeapon_PrintErrorMSG(int category, int type, int a1, int a2){
	GhostWeapon_PrintErrorMSG(category, type, a1, a2, -1);
}

void GhostWeapon_PrintErrorMSG(int category, int type, int a1){
	GhostWeapon_PrintErrorMSG(category, type, a1, -1);
}

void GhostWeapon_PrintErrorMSG(int category, int type){
	GhostWeapon_PrintErrorMSG(category, type, -1);
}